#import "./errors.jsligo" "Errors"
#import "./token_total_supply.jsligo" "TokenTotalSupply"

type seconds = nat;
export type permitKey = [address, bytes];
export type permits = big_map<permitKey, timestamp>;
export type userExpiries = big_map<address, option<seconds>>;
export type permitExpiries = big_map<permitKey, option<seconds>>;

export type t = {
    admin: address,
    counter: nat,
    defaultExpiry: seconds,
    maxExpiry: seconds,
    permits: permits,
    userExpiries: userExpiries,
    permitExpiries: permitExpiries,
    tokenTotalSupply : TokenTotalSupply.t
};

const get_user_defined_expiry = ([from_, ext]: [address, t]) : option<seconds> => {
    return match (Big_map.find_opt(from_, ext.userExpiries), {
        None: () => (Some(ext.defaultExpiry)),
        Some: (exp: option<seconds>) => exp
    });
};

const getExpiry = ([ext, paramPermitKey]: [t, permitKey]) : seconds => {
    match ((Big_map.find_opt([paramPermitKey[0], paramPermitKey[1]], ext.permitExpiries) as option<option<seconds>>), {
        None: () => {
                match ((Big_map.find_opt(paramPermitKey[0], ext.userExpiries) as option<option<seconds>>), {
                    None: () => ext.defaultExpiry,
                    Some: (exp: option<seconds>) => {
                        match (exp, {
                            None: () => ext.defaultExpiry,
                            Some: (t: seconds) => t
                        })
                    }
                })
            },
        Some: (p: option<seconds>) => {
                match (p, {
                    None: () => ext.defaultExpiry,
                    Some: (exp: seconds) => exp
                })
            }
    })
};


export const assertAdmin = (ext : t) : unit =>
    assert_with_error((Tezos.get_sender() == ext.admin), Errors.requiresAdmin);

export const setAdmin = ([ext, admin] : [t, address]) : t => {
    assertAdmin(ext);
    return { ...ext, admin : admin };
};

export const setSupply = ([ext, supply] : [t, TokenTotalSupply.t]) : t => {
    return { ...ext, tokenTotalSupply : supply }
};

export const addPermit = ([ext, paramPermitKey] : [t, permitKey]) : t => {
    let now = Tezos.get_now();
    return { ...ext,
        permits : Big_map.add(paramPermitKey, now, ext.permits),
        counter : ext.counter + (1 as nat)
    }
};

export const updatePermit = ([ext, paramPermitKey] : [t, permitKey]) : t => {
    let now = Tezos.get_now();
    return { ...ext,
        permits : Big_map.update(paramPermitKey, (Some(now)), ext.permits),
        counter : ext.counter + (1 as nat)
    }
};

export const _checkNotExpired = ([ext, submissionTimestamp, paramPermitKey]: [t, timestamp, permitKey]) : unit => {
    let effectiveExpiry: seconds = getExpiry(ext, paramPermitKey);
    assert_with_error((abs (Tezos.get_now() - submissionTimestamp) >= effectiveExpiry), Errors.dupPermit);
};

export const transferPresigned = ([ext, paramPermitKey]: [t, permitKey]): [bool, t] => {
    let permitSubmitTime: timestamp =
        match (Big_map.find_opt(paramPermitKey, ext.permits), {
            None: () => (0 as timestamp),
            Some: (exp: timestamp) => exp
        });
    if (permitSubmitTime == (0 as timestamp)) {
        return [false, ext]
    } else {
        let effectiveExpiry =
            match (Big_map.find_opt(paramPermitKey, ext.permitExpiries), {
                None: () => {
                    match (Big_map.find_opt(paramPermitKey[0], ext.userExpiries), {
                        None: () => (Some(ext.defaultExpiry)),
                        Some: (exp: option<seconds>) => exp
                    })
                },
                Some: (exp: option<seconds>) => exp
            });
        return match (effectiveExpiry, {
            None: () => (failwith(Errors.missingExpiry) as [bool, t]),
            Some: (effective_exp: seconds) => {  
                let permits = Big_map.remove(paramPermitKey, ext.permits);
                let isAuthorised = abs ((Tezos.get_now()) - permitSubmitTime) < effective_exp;
                [isAuthorised, { ...ext, permits : permits }]
            }
        });
    }
};